/**** Basic setup for defining and drawing objects ****/

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <stdio.h>
#include <iterator>
#include <algorithm>

#ifndef __INCLUDEGEOMETRY
#define __INCLUDEGOEMETRY

#include "sceneobject.h"

const int numobjects = 6; // number of objects for buffer 
const int numperobj  = 3 ;
const int ncolors = 4 ; 
GLuint buffers[numperobj*numobjects+ncolors+1] ; // List of buffers for geometric data 
GLuint objects[numobjects] ; // For each object
GLenum PrimType[numobjects] ;
GLsizei NumElems[numobjects] ; 

enum {Vertices, Colors, Elements} ; // For arrays for object 
enum {FLOOR, CUBE, DUDE, GOURD, CHESSOBJ, REDOAK} ; // For objects, for the floor

#define BUFFER_OFFSET(bytes) ((GLubyte *) NULL + (bytes))
#define NumberOf(array) (sizeof(array)/sizeof(array[0])) 

void initobject(GLuint object, GLfloat * vert, GLint sizevert, GLfloat * col, GLint sizecol, GLubyte * inds, GLint sizeind, GLenum type) ;
void initobjectnocol(GLuint object, GLfloat * vert, GLint sizevert, GLubyte * inds, GLint sizeind, GLenum type) ;
void drawobject(GLuint object) ; 
void initcolorscube (void) ;
void drawcolor(GLuint object, GLuint color) ;
//void inittexture (const char * filename, GLuint program, int size, GLfloat *texsize, GLubyte *texture) ;
void drawtexture(GLuint object, GLuint texture) ;


// This function takes in a vertex, color, index and type array 
// And does the initialization for an object.  
// The partner function below it draws the object 
void initobject(GLuint object, GLfloat * vert, GLint sizevert, GLfloat * col, GLint sizecol, GLubyte * inds, GLint sizeind, GLenum type) {
	int offset = object * numperobj ; 
	glBindBuffer(GL_ARRAY_BUFFER, buffers[Vertices+offset]) ; 
	glBufferData(GL_ARRAY_BUFFER, sizevert, vert,GL_STATIC_DRAW);
	glVertexPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 
	glEnableClientState(GL_VERTEX_ARRAY) ; 
	glBindBuffer(GL_ARRAY_BUFFER, buffers[Colors+offset]) ; 
	glBufferData(GL_ARRAY_BUFFER, sizecol, col,GL_STATIC_DRAW);
	glColorPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 
	glEnableClientState(GL_COLOR_ARRAY) ; 
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffers[Elements+offset]) ; 
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeind, inds,GL_STATIC_DRAW);
	PrimType[object] = type ; 
	NumElems[object] = sizeind ; 
}

// Very basic code to read a ppm file
// And then set up buffers for texture coordinates
/* void inittexture (const char * filename, GLuint program, int size, GLfloat texsize[][2], */
/* 		  GLubyte texture[][256][3], int index) { */
/* 	int i,j,k ; */
/* 	FILE * fp ;  */
/* 	GLint err ;  */
/* 	assert(fp = fopen(filename,"rb")) ; */
/* 	fscanf(fp,"%*s %*d %*d %*d%*c") ; */
/* 	for (i = 0 ; i < 256 ; i++) */
/* 		for (j = 0 ; j < 256 ; j++) */
/* 			for (k = 0 ; k < 3 ; k++) */
/* 			  fscanf(fp,"%c",&(texture[i][j][k])) ; */
/* 	fclose(fp) ;   */

/* 	// Set up Texture Coordinates */
/* 	glBindBuffer(GL_ARRAY_BUFFER, buffers[numobjects*numperobj+ncolors]) ;  */
/* 	glBufferData(GL_ARRAY_BUFFER, size, texsize,GL_STATIC_DRAW); */
/* 	glActiveTexture(GL_TEXTURE0) ;  */
/* 	glEnable(GL_TEXTURE_2D) ;  */
/* 	glTexCoordPointer(2,GL_FLOAT,0,BUFFER_OFFSET(0)) ;  */
/* 	glEnableClientState(GL_TEXTURE_COORD_ARRAY) ;  */

/* 	glBindTexture (GL_TEXTURE_2D, texNames[index]) ;  */
/* 	glTexImage2D(GL_TEXTURE_2D,0,GL_RGB, 256, 256, 0, GL_RGB, GL_UNSIGNED_BYTE, */
/* 			texture) ; */
/* 	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR) ;  */
/* 	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR) ;  */
/* 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT) ; */
/* 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT) ; */
/* 	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND); */

/* 	// Define a sampler.  See page 709 in red book, 7th ed. */
/* 	GLint texsampler ;  */
/* 	texsampler = glGetUniformLocation(program, "tex") ;  */
/* 	glUniform1i(texsampler,0) ; // Could also be GL_TEXTURE0  */
/* 	istex = glGetUniformLocation(program,"istex") ;  */
/* } */

// Simple function to set the color separately.  Takes out colors
void initobjectnocol(GLuint object, GLfloat * vert, GLint sizevert, GLubyte * inds, GLint sizeind, GLenum type) {
	int offset = object * numperobj ; 
	glBindBuffer(GL_ARRAY_BUFFER, buffers[Vertices+offset]) ; 
	glBufferData(GL_ARRAY_BUFFER, sizevert, vert,GL_STATIC_DRAW);
	glVertexPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 
	glEnableClientState(GL_VERTEX_ARRAY) ; 
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffers[Elements+offset]) ; 
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeind, inds,GL_STATIC_DRAW);
	PrimType[object] = type ; 
	NumElems[object] = sizeind ; 
}

// Simple function to init a bunch of color buffers for the cube 
void initcolorscube (void) {
	int base = numobjects * numperobj ; 
	for (int i = 0 ; i < ncolors ; i++) {
		for (int j = 0 ; j < 8 ; j++) 
			for (int k = 0 ; k < 3 ; k++) 
				cubecol[j][k] = _cubecol[i][k] ; 
		glBindBuffer(GL_ARRAY_BUFFER, buffers[base+i]) ; 
		glBufferData(GL_ARRAY_BUFFER, sizeof(cubecol), cubecol ,GL_STATIC_DRAW);
		glColorPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 
		glEnableClientState(GL_COLOR_ARRAY) ;       
	}  
}
// And a function to draw with them, similar to drawobject but with color
void drawcolor(GLuint object, GLuint color) {
	int offset = object * numperobj ; 
	int base = numobjects * numperobj ; 
	glBindBuffer(GL_ARRAY_BUFFER, buffers[Vertices+offset]) ; 
	glVertexPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 
	glEnableClientState(GL_VERTEX_ARRAY) ; 
	glBindBuffer(GL_ARRAY_BUFFER, buffers[base+color]) ; // Set color correctly 
	glColorPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 
	glEnableClientState(GL_COLOR_ARRAY) ; 
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffers[Elements+offset]) ; 
	glDrawElements(PrimType[object], NumElems[object], GL_UNSIGNED_BYTE, BUFFER_OFFSET(0)) ; 
}

// And a function to draw with textures, similar to drawobject
void drawtexture(GLuint object, GLuint texture) {
	int offset = object * numperobj ; 
	int base = numobjects * numperobj + ncolors ; 
	glBindBuffer(GL_ARRAY_BUFFER, buffers[Vertices+offset]) ; 
	glVertexPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 
	glEnableClientState(GL_VERTEX_ARRAY) ; 

	// Even with texturing, so we can blend if needed.
	glBindBuffer(GL_ARRAY_BUFFER, buffers[Colors+offset]) ; 
	glColorPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 
	glEnableClientState(GL_COLOR_ARRAY) ; 

	glActiveTexture(GL_TEXTURE0) ; 
	glEnable(GL_TEXTURE_2D) ; 
	glBindTexture(GL_TEXTURE_2D, texture) ; 
	glEnableClientState(GL_TEXTURE_COORD_ARRAY) ; 
	glBindBuffer(GL_ARRAY_BUFFER, buffers[base]) ; // Set texcoords
	glTexCoordPointer(2, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffers[Elements+offset]) ; 
	glDrawElements(PrimType[object], NumElems[object], GL_UNSIGNED_BYTE, BUFFER_OFFSET(0)) ; 

}

void drawobject(GLuint object) {
	int offset = object * numperobj ; 
	glBindBuffer(GL_ARRAY_BUFFER, buffers[Vertices+offset]) ; 
	glVertexPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 
	glEnableClientState(GL_VERTEX_ARRAY) ; 
	glBindBuffer(GL_ARRAY_BUFFER, buffers[Colors+offset]) ; 
	glColorPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0)) ; 
	glEnableClientState(GL_COLOR_ARRAY) ; 
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buffers[Elements+offset]) ; 
	glDrawElements(PrimType[object], NumElems[object], GL_UNSIGNED_BYTE, BUFFER_OFFSET(0)) ; 
}

#endif
